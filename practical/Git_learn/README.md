### 集中式（svn）
    优点：代码存放在单一的服务器上，便于项目的管理
    缺点：
         服务器宕机： 员工写的代码得不到保障
         服务器炸了： 整个项目的历史记录都会丢失
          
### 分布式（git）
    git每次存放的都是项目的完整的快照，需要需要的磁盘空间相对大一点
    git团队对代码做了极致的压缩，最终需要的实际空间比svn多不了太多，
    但回滚速度快
    
### 安装
[下载git](https://git-scm.com/downloads)

# git参考
[git 学习文档](https://git-scm.com/doc)

### 初始化
    git config --global user.name "xx"
    git config --global user.email xxx@xx.com
    可以查看config：  git config --list
    
### 区域    
    1. 工作区
    2. 暂存区
    3. 版本库
    
### 对象
    Git 对象：
        Git是一个内容寻址文件系统，听起来很酷。
        这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。
        你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。
        可以通过底层命令 git hash-object 可将任意数据保存于 
        .git/objects 目录（即 对象数据库），并返回指向该数据对象的唯一的键。
        然而，记住文件的键并不现实；另一个问题是，在这个（简单的版本控制）系统中，
        文件名并没有被保存——我们仅保存了文件的内容。 
        上述类型的对象我们称之为 数据对象（blob object）。
        利用 git cat-file -t 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值
    树对象：
        树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。
        Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。
        所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，
        数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），
        每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。
    提交对象
        现在就有了三个树对象，分别代表我们想要跟踪的不同项目快照。
        然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。
        并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 
        而以上这些，正是提交对象（commit object）能为你保存的基本信息。
        可以通过调用 commit-tree 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，
        以及该提交的父提交对象（如果有的话）。
        
#### 对 .git文件的认识
初始化仓库：找到想与git关联的目录，执行  git init

    hooks 该目录包含客户端或服务端的钩子脚本
    info  该目录包含一个全局性排除文件
    logs  该目录保存日志信息
    objects  该目录存储所有数据内容
    refs   该目录存储 指向数据（分支）的提交对象的指针
    config  该文件包含项目特有的配置选项
    description  该文件用来显示对仓库的描述信息
    HEAD  该文件指示目前被输出的分支
    index 该文件保存暂存区的信息
   
########## git的命令
git(blob)对象底层命令：
    git hash-object -w 指定的文件
    生成一个key（hash）：value存放到.git/objects
    
tree对象底层命令：
    git update-index --add --cacheinfo 100644 hash 文件名
    往暂存区添加一个记录，让git对象对应上文件名，存放到.git/index
    
commit对象底层命令：
    echo "xx" | git commit-tree treehash
    生成一个提交对象，存放到.git/objects 

查看暂存区：
    git ls-files -s        
         
1. git init
    初始化仓库，对指定的目录进行git管理
    
2. git add <指定路径>
    添加内容到index（将修改添加到暂存区）
    底层会调用：
    git hash-object -w 文件名 （修改了多少个工作目录中的文件每次命令就要被执行多少次）
    git update-index...
    
3. git commit
    <选项：  -m  message 备注提交信息> 
    < -a 跳过使用暂存区，将已跟踪的文件全部提交> etc
    将暂存区提交到版本库
    底层会调用：
    git write-tree
    git write-commit
    
4. git status
    检查文件当前处于什么状态，
    工作目录的文件的状态分未追踪，已追踪，而已追踪又分已提交，已修改，已暂存
    
5. git diff
    查看已暂存和未暂存的更新
    <选项 --cached  --staged>
    
6. git log 
    查看日志
        
7. git rm --cached <file>
    移除暂存区中的指定文件
    
8. git branch 分支名
    分支：分支的本质是一个提交对象
    HEAD文件是一个指针，它默认指向master分支，
    切换分支是其实就是让HEAD指向不同的分支
    每次有新的提交时HEAD都会带着当前指向的分支一起前进
    当所有文件是已提交，切换分支时会改变HEAD文件中分支指向和
    暂存区内容以及 工作目录
    在切换分支时，第一次如果当前分支上有未提交的暂存，就会被提交
    
    不带分支名则显示分支列表
    创建一个新分支，但不会切换到新分支.
    <选项： -d/D 分支名   删除分支>
    < -v 可以查看一个分支的最后一次提交>
    <commitHash（提交对象的哈希值） 新建一个分支并指向 对应的已提交对象>
    
9. git checkout 分支名
    切换分支
...................    
    
# 简要摘抄官网文档：
1. 获取 Git 仓库
    通常有两种获取 Git 项目仓库的方式：
        将尚未进行版本控制的本地目录转换为 Git 仓库:   git init               ~~~~~
        从其它服务器 克隆 一个已存在的 Git 仓库:      git clone url           ~~~~~
      
    两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。
     
2. 记录每次更新到仓库
    工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪   
    
    已跟踪的文件就是 Git 已经知道的文件。
    
    未跟踪就是它不知道的
    
    可以用 git status 命令查看哪些文件处于什么状态                   ~~~~~
    
    没有红字和绿字就是已提交了
    
    支名是“master”,这是默认的分支名
    
    使用命令 git add 开始跟踪一个文件                           ~~~~~
    
    Changes to be committed 这行下面的，就说明是已暂存状态
     
    Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区
     
    使用 git status -s 命令或 git status --short 命令，你将得到一种格式更为紧凑的输出。             ~~~~~
    新添加的未跟踪文件前面有 ?? 标记。添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。
    左栏指明了暂存区的状态，右栏指明了工作区的状态。
    
    创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 
    文件 .gitignore 的格式规范如下：
        所有空行或者以 # 开头的行都会被 Git 忽略。
        可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。
            （glob 模式：星号（*）匹配零个或多个任意字符；
             [abc] 匹配任何一个列在方括号中的字符；
             问号（?）只匹配一个任意字符；
             如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配；
             使用两个星号（**）表示匹配任意中间目录）
        匹配模式可以以（/）开头防止递归。
        匹配模式可以以（/）结尾指定目录。
        要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。
    
    git diff  此命令比较的是工作目录中当前文件和暂存区域快照之间的差异                  ~~~~~
    
    git diff --staged/--cached 这命令将比对已暂存文件与最后一次提交的文件差异          ~~~~~
    
    提交命令 git commit  进入editor编辑备注                               ~~~~~
    
    可以在 git commit 命令后添加 -m 选项(git commit -m message)，将提交信息与命令放在同一行         ~~~~~
    
    git commit 加上 -a 选项(git commit -a)，                                             ~~~~~
    Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤    
    
    可以用 git rm 命令 完成移除某个文件的工作                   ~~~~~
    要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f(git rm -f file)          ~~~~~
    想让文件保留在磁盘，但是并不想让 Git 继续跟踪 (git rm --cached file)                ~~~~~
    
    要在 Git 中对文件改名  git mv file_from file_to                                      ~~~~~
    该命令相当于做了  1. mv file_from file_to   2. git rm file_from  3. git add file_to

3. 查看提交历史
    想回顾下提交历史的命令 git log                                                 ~~~~~     
    不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。
    正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。
     
    git log 的常用选项 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出） 
    后面还可以加上  -2 选项来只显示最近的两次提交 (git log -p -num)                   ~~~~~
    
    想看到每次提交的简略统计信息，可以使用 --stat 选项  (git log --stat)               ~~~~~
    
    可以使用不同于默认格式的方式展示提交历史 选项是 --pretty
    内建的子选项 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。(git log --pretty=oneline) ~~~~~
    另外还有 short，full 和 fuller 选项
    内建的子选项 format 选项 ，可以定制记录的显示格式，如 git log --pretty=format:"%H - %an, %ar : %s"  ~~~~~
    选项	说明
    %H      提交的完整哈希值  
    %h      提交的简写哈希值   
    %T      树的完整哈希值 
    %t      树的简写哈希值
    %P      父提交的完整哈希值 
    %p      父提交的简写哈希值
    %an     作者名字
    %ae     作者的电子邮件地址
    %ad     作者修订日期（可以用 --date=选项 来定制格式）
    %ar     作者修订日期，按多久以前的方式显示
    %cn     提交者的名字
    %ce     提交者的电子邮件地址
    %cd     提交日期
    %cr     提交日期（距今多长时间）
    %s      提交说明
    
    --since 和 --until 这种按照时间作限制的选项很有用，
    如列出最近两周的所有提交： git log --since=2.weeks                   ~~~~~
    
    用 --author 选项显示指定作者的提交                               ~~~~~
    
4. 撤消操作
    有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。
    此时，可以运行带有 --amend 选项的提交命令来重新提交（git commit --amend）    ~~~~~
    
    git reset HEAD <file>...    可以取消暂存，使用时要小心                          ~~~~~
    git restore --staged <file>...  可以取消暂存，使用时要小心                       ~~~~~
    
    git checkout -- file  撤消对文件的修改，使用时要小心                           ~~~~~
    git restore file    撤消对文件的修改，使用时要小心                         ~~~~~
    
*    记住，在 Git 中任何 已提交 的东西几乎总是可以恢复的。
    
5. 远程仓库的使用
    想查看你已经配置的远程仓库服务器，可以运行 git remote 命令             ~~~~~
    
    指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。(git remote -v)   ~~~~~ 
    
    运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写    ~~~~~
    
    从远程仓库中抓取与拉取  git fetch <remote>                             ~~~~~
    它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。
    
    可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。               ~~~~~
    
    git push <remote> <branch>  运行这个命令就可以将你所做的备份到服务器        ~~~~~
    
    想要查看某一个远程仓库的更多信息，可以使用 git remote show <remote> 命令   ~~~~~
    
    你可以运行 git remote rename 来修改一个远程仓库的简写名                   ~~~~~
    
    想要移除一个远程仓库 git remote remove <shortname> 或 git remote rm <shortname>     ~~~~~
    
6. 打标签
    在 Git 中列出已有的标签非常简单，只需要输入 git tag                        ~~~~~
    
    只对 1.8.5 系列感兴趣  git tag -l "v1.8.5*"                             ~~~~~
    
    Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。
    
    创建附注标签,当你在运行 tag 命令时指定 -a 选项, -m 选项指定了一条将会存储在标签中的信息
    如  git tag -a v1.4 -m "my version 1.4"                                           ~~~~~
    
    通过使用 git show 标签名  命令可以看到标签信息和与之对应的提交信息                       ~~~~~
    
    只需要提供标签名字来使用轻量标签 git tag v1                        ~~~~~
    
    要在过去的提交上打标签，你需要在命令的末尾指定提交的校验和(如git tag -a v1 9e2f23a)   ~~~~~
    
    运行 git push origin <tagname> 显式地推送标签到共享服务器上                 ~~~~~
    
    使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。   ~~~~~
    
    要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>                       ~~~~~
    
    要从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库    ~~~~~
    或者
    git push <remote> --delete <tagname>                    ~~~~~
    
    想查看某个标签所指向的文件版本，可以使用 git checkout 命令,
    虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态
    
7. 别名    
    可以通过 git config 文件来轻松地为每一个命令设置一个别名,如git config --global alias.co checkout       ~~~~~
    只需要输入 git co  执行checkout命令
    
8. 分支简介
    创建一个分支， 你需要使用 git branch 分支名  命令                                ~~~~~
    
    一个名为 HEAD 的特殊指针,它是一个指针，指向当前所在的本地分支.将 HEAD 想象为当前分支的别名
    
    使用 git log 命令加参数 --decorate  查看各个分支当前所指的对象              ~~~~~
    
    要切换到一个已存在的分支，你需要使用 git checkout 分支名  这条命令做了两件事：            ~~~~~
    一是使 HEAD 指到 对应 分支，二是将工作目录恢复成 对应 分支所指向的快照内容                    
    
    HEAD 分支会随着提交操作自动向前移动
    
    如果 Git 不能干净利落地完成分支切换这个任务，它将禁止切换分支。
    
    运行 git log --oneline --decorate --graph --all，                             ~~~~~
    它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况
    
    在创建一个新分支后立即切换过去，这可以用 git checkout -b <newbranchname> 一条命令搞定。  ~~~~~
    
    
9. 分支的新建与合并
    使用 git merge 命令来达到合并两个分支                                                    ~~~~~
    当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，
    只会简单的将指针向前推进，这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）;
    开发历史从一个更早的地方开始分叉开来(diverged), 两或多个分支并排，
    想要让并排的两个分支合并，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，
    做一个简单的三方合并。Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。
    这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。
    
    使用带 -d 选项的 git branch 命令来删除分支(git branch -d 分支名)                ~~~~~
    
    遇到冲突时的分支合并： 如果你对分支的修改和另一个并排分支的修改都涉及到同一个文件的同一处，
    在合并它们的时候就会产生合并冲突。可以在合并冲突后的任意时刻使用 git status 命令
    来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件，
    解决冲突必须 选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容
    解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决
    可以输入 git commit 来完成合并提交
    
    需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令                          ~~~~~
    --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。
    
10. 远程分支
    通过 git ls-remote <remote> 来显式地获得远程引用的完整列表，              ~~~~~
    或者通过 git remote show <remote> 获得远程分支的更多信息                   ~~~~~
    
    Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 
    创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master
    即默认的远程仓库的默认分支为 origin/master（名字）
    
    要与给定的远程仓库同步数据，运行 git fetch <remote> 命令                  ~~~~~
    运行这个命令. 会查找 remote 是哪一个服务器,
    从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。
    
    运行 git push <remote> <branch>   向远程仓库的对应分支推送数据                  ~~~~~
    
    运行 git push origin <本地某分支名>:<远程分支名>     将本地分支向远程仓库推送数据并指定名字     ~~~~~
    
    当抓取到新的远程跟踪分支时，不会有一个新的分支——只有一个不可以修改的 origin/分支名  指针
    运行 git merge origin/分支名   将远程分支合并到当前所在的分支                         ~~~~~     
    
    git checkout -b 分支名 origin/分支名                               ~~~~~     
    这会给你一个用于工作的本地分支，并且起点位于 origin/分支名
    
    运行 git checkout -b <branch> <remote>/<branch>  创建一个跟踪分支与远程仓库的某分支关联      ~~~~~
    
    git checkout --track origin/分支名        创建远程仓库的某分支的跟踪分支              ~~~~~     
    
    想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项                       ~~~~~     
    
    git fetch --all; git branch -vv  要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库   ~~~~~
    
    有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令    ~~~~~
    
    可以运行带有 --delete 选项的 git push 命令来删除一个远程分支(git push <remote> --delete <branch>)   ~~~~~
    
11. 变基(rebase)
    可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样.   
    这种操作就叫做 变基（rebase）, 如
    git checkout experiment
    git rebase master       将当前分支(experiment)上的所有修改都移至  master                       ~~~~~
    变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交
    
    无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。
    变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。
    
    使用 git rebase 命令的 --onto 选项,如
    git rebase --onto master server client                                              ~~~~~
    以上命令的意思是：  取出 client 分支，找出它从 server 分支分歧之后的补丁， 
    然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”
    
    使用 git rebase <basebranch> <topicbranch> 命令                        ~~~~~
    可以直接将主题分支变基到目标分支上
     
    如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。
    如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。
     
    执行 git rebase origin/master或使用 git pull --rebase 命令
    在一个被变基然后强制推送的分支上再次执行变基
    
    
    